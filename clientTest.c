
//Post Quantum TCP Chat Client Pragram

#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<netdb.h>
#include<pthread.h>
#include<unistd.h>
#include<string.h>
#include<math.h>
#include<ctype.h>
#include<time.h>
#include<ncurses.h>
#include<signal.h>
#include<oqs/oqs.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/buffer.h>

#define NONCE_LEN 16
#define NONCE_HEX_LEN (NONCE_LEN * 2 + 1) // Should be 33
#define SHA256_HEX_LEN (SHA256_DIGEST_LENGTH * 2 + 1)
#define IV_LEN 12
#define TAG_LEN 16
#define MSG_BUF_SIZE 256

const uint8_t HARDCODED_SERVER_PUB_KEY[] = {
	0x38, 0x80, 0xe2, 0x58, 0x7b, 0x7f, 0x10, 0x30, 0xd6, 0x86, 0xa9, 0xf1, 
    0xbd, 0xc4, 0x33, 0x14, 0xb9, 0x68, 0x24, 0x98, 0x67, 0x10, 0xe5, 0xff, 
    0xc2, 0x9b, 0x6b, 0x9d, 0xef, 0xdd, 0xce, 0xc6, 0x50, 0x9e, 0x12, 0x79, 
    0xc5, 0x8c, 0x2a, 0x0b, 0x0d, 0x88, 0x89, 0x1a, 0x22, 0x35, 0x1c, 0x7f, 
    0x14, 0x89, 0xca, 0x88, 0xe8, 0x7e, 0x61, 0xee, 0xcc, 0x95, 0x21, 0xc7, 
    0xbf, 0x3e, 0x64, 0x34, 0x98, 0x6f, 0x02, 0xd7, 0xc6, 0x6e, 0x8e, 0x48, 
    0xca, 0x8f, 0xb6, 0x85, 0x31, 0x9e, 0x58, 0xc6, 0xab, 0x5e, 0xcb, 0x40, 
    0x21, 0xc4, 0xdc, 0xb8, 0xeb, 0x1a, 0xec, 0xae, 0x86, 0xfa, 0xfc, 0xb4, 
    0x49, 0x7a, 0x5f, 0x5a, 0x2a, 0x01, 0xf0, 0x1d, 0xa3, 0x14, 0x42, 0xdd, 
    0x24, 0x20, 0xed, 0x83, 0xd4, 0xd9, 0x86, 0x84, 0x94, 0x8d, 0x19, 0xc5, 
    0xdd, 0x95, 0x28, 0xc9, 0xe1, 0x1f, 0x21, 0xa1, 0xde, 0x34, 0x60, 0x5e, 
    0xa5, 0x65, 0x8f, 0xe7, 0xc5, 0x0b, 0x4a, 0xed, 0x4d, 0x86, 0xee, 0x99, 
    0x2d, 0x80, 0x3c, 0x46, 0xd7, 0x74, 0x03, 0x04, 0xe2, 0xa1, 0x44, 0xdc, 
    0x5e, 0x43, 0x39, 0x51, 0x5e, 0x76, 0x95, 0x6f, 0xee, 0x03, 0xb3, 0xac, 
    0x41, 0xe3, 0x54, 0xc6, 0x8e, 0x51, 0xb8, 0xa8, 0xfb, 0xe6, 0xd1, 0x4e, 
    0x23, 0x3d, 0x2a, 0xcb, 0x43, 0x74, 0x59, 0x41, 0x24, 0x67, 0x0a, 0xe2, 
    0x8b, 0x27, 0xe8, 0x52, 0x45, 0x45, 0xbe, 0x88, 0xd6, 0xb8, 0x35, 0x3e, 
    0xbc, 0xe7, 0x88, 0x33, 0x4a, 0x33, 0x67, 0x95, 0x6b, 0xf1, 0x49, 0x5e, 
    0xa5, 0x04, 0xbb, 0xb7, 0xe0, 0x14, 0x50, 0x36, 0x84, 0x03, 0xa8, 0x31, 
    0x85, 0x3a, 0x3d, 0x09, 0xda, 0x14, 0x3d, 0xa1, 0x60, 0x37, 0xfb, 0xc6, 
    0xaf, 0x3a, 0xe0, 0x8f, 0xfe, 0x93, 0x29, 0x2d, 0x99, 0xf1, 0x52, 0x86, 
    0x81, 0xe3, 0x02, 0xf2, 0x37, 0xac, 0xb0, 0x5e, 0x9b, 0x75, 0x80, 0x99, 
    0x3b, 0xa4, 0x41, 0xc2, 0x1e, 0xb4, 0x75, 0xe3, 0xea, 0x38, 0x5a, 0x51, 
    0x2a, 0x45, 0x0b, 0x47, 0xc7, 0x64, 0x9f, 0xbe, 0x3c, 0x94, 0x1e, 0xe1, 
    0x0a, 0x43, 0x1b, 0xae, 0x5b, 0x32, 0xe6, 0x25, 0x09, 0xc3, 0xe5, 0xe9, 
    0x6c, 0xc3, 0x9d, 0x4b, 0x82, 0xbc, 0xf3, 0xfd, 0x06, 0x2a, 0xfe, 0xe6, 
    0xc5, 0xa1, 0x70, 0x87, 0xce, 0xce, 0x42, 0xfd, 0x5f, 0xac, 0xe7, 0xe5, 
    0x67, 0x5d, 0x92, 0x84, 0x0a, 0x5f, 0x7e, 0x5c, 0x1d, 0x8c, 0x41, 0x6a, 
    0x7d, 0x83, 0x91, 0x6e, 0xed, 0x84, 0x17, 0x27, 0xe0, 0xd6, 0x31, 0x93, 
    0x66, 0xef, 0x45, 0x51, 0x87, 0x08, 0x01, 0xf3, 0x30, 0x9d, 0x86, 0x48, 
    0x07, 0x29, 0x49, 0x28, 0xa3, 0x45, 0x66, 0x66, 0xbc, 0x36, 0x75, 0xcc, 
    0x12, 0x0a, 0x0d, 0x93, 0x2c, 0x8f, 0x19, 0x89, 0x18, 0x3c, 0x1f, 0x0a, 
    0xff, 0x6f, 0xbe, 0x6a, 0x89, 0x87, 0x2b, 0x41, 0x45, 0x31, 0x12, 0x98, 
    0xa6, 0xb8, 0x55, 0x29, 0x69, 0x7f, 0xe1, 0xcd, 0x1a, 0xd0, 0xbb, 0xfa, 
    0xaa, 0xf7, 0x37, 0xda, 0x42, 0xed, 0x19, 0xda, 0x9a, 0x7e, 0x7d, 0x32, 
    0xdb, 0xb8, 0xeb, 0x59, 0x48, 0xd2, 0xf4, 0x06, 0x7d, 0xf3, 0xf9, 0x7e, 
    0xad, 0xc6, 0x9f, 0xd0, 0x08, 0x45, 0x79, 0xc1, 0xc9, 0xd1, 0x16, 0x1b, 
    0x13, 0x85, 0x45, 0xb9, 0xde, 0x9c, 0x9d, 0x1c, 0x3f, 0x3e, 0x01, 0x4a, 
    0x59, 0x72, 0x4b, 0xca, 0x8c, 0xdd, 0xd9, 0xfe, 0x1f, 0xc2, 0x97, 0xeb, 
    0xea, 0xde, 0x99, 0x65, 0xf8, 0xb5, 0x77, 0x18, 0xae, 0x97, 0x75, 0x8d, 
    0x03, 0xf9, 0xfa, 0x47, 0x37, 0xfe, 0x95, 0x35, 0xe8, 0x7a, 0xeb, 0x42, 
    0xf8, 0x8b, 0x62, 0xd5, 0xd1, 0x59, 0x00, 0xa2, 0x99, 0xa4, 0xe4, 0xe2, 
    0xdd, 0xca, 0x97, 0x36, 0xb6, 0xfc, 0xa2, 0x8a, 0x70, 0x4d, 0xc9, 0xdb, 
    0xc6, 0x14, 0x3b, 0xfe, 0x0e, 0xe8, 0x90, 0x83, 0xcd, 0x0e, 0x18, 0x58, 
    0x77, 0x01, 0xa7, 0x51, 0x42, 0x98, 0xc4, 0xab, 0x61, 0x95, 0x6e, 0xf7, 
    0x59, 0x29, 0x5b, 0x9b, 0x61, 0xec, 0x5b, 0xc7, 0x31, 0x4b, 0x40, 0xae, 
    0xab, 0xb9, 0x7a, 0xd7, 0xc5, 0x8b, 0x02, 0xed, 0x9e, 0xac, 0x6f, 0x22, 
    0xcb, 0xd0, 0xb1, 0xbe, 0x64, 0x97, 0x2c, 0x74, 0x55, 0x53, 0xe8, 0xb7, 
    0x92, 0x47, 0xcb, 0xb1, 0x7d, 0xd3, 0xb1, 0x58, 0x47, 0xf4, 0xb4, 0xd6, 
    0x0e, 0x04, 0xe0, 0x9c, 0xc0, 0xf0, 0xe4, 0x32, 0xf4, 0x39, 0xdf, 0x81, 
    0x06, 0x7f, 0x97, 0x1d, 0x23, 0xcf, 0xaa, 0x4d, 0x13, 0xb6, 0x8f, 0x3a, 
    0xb4, 0xb8, 0x7b, 0xf8, 0x7c, 0x28, 0x93, 0xca, 0x49, 0x3f, 0x37, 0xa5, 
    0x43, 0xc3, 0x74, 0x95, 0xb3, 0xcb, 0x6f, 0x9b, 0xda, 0xb4, 0x69, 0x91, 
    0x3c, 0x97, 0x38, 0xc6, 0x17, 0x19, 0x41, 0x5c, 0x79, 0x82, 0xfd, 0xc9, 
    0xe8, 0xbe, 0xf3, 0x5b, 0xb8, 0xf3, 0xb9, 0x16, 0x14, 0xdc, 0x84, 0x5a, 
    0x1f, 0x59, 0x69, 0xd9, 0x7e, 0x12, 0x7f, 0x38, 0x70, 0x4f, 0x64, 0x09, 
    0x79, 0x52, 0xd9, 0x1e, 0xa4, 0xd5, 0x47, 0x81, 0x3b, 0x32, 0x93, 0xd9, 
    0xc4, 0xe7, 0xad, 0xcd, 0x01, 0xb6, 0x6e, 0xde, 0x6b, 0x41, 0x6a, 0xd9, 
    0x67, 0x40, 0xc9, 0x2a, 0x45, 0x68, 0x4b, 0x09, 0x26, 0xa9, 0x7e, 0x17, 
    0xd7, 0xd6, 0xdc, 0x54, 0x2d, 0x00, 0xd1, 0x61, 0x03, 0xab, 0x14, 0x45, 
    0xf9, 0x08, 0x52, 0xbd, 0xdb, 0x14, 0x2a, 0xf9, 0xc7, 0xed, 0xb7, 0x7a, 
    0xd0, 0x79, 0x75, 0xd8, 0x16, 0x08, 0x34, 0xca, 0x7e, 0x72, 0x32, 0xfa, 
    0xc9, 0xd4, 0x97, 0xe6, 0xa8, 0x1b, 0xa0, 0xad, 0xcf, 0x71, 0x9b, 0x50, 
    0x78, 0x89, 0x17, 0x66, 0xa9, 0x12, 0x58, 0x07, 0x21, 0x97, 0x85, 0xa4, 
    0xe3, 0xf6, 0x6a, 0xc2, 0xcd, 0xcf, 0x85, 0x16, 0xbc, 0x31, 0xe4, 0x22, 
    0xfd, 0x59, 0xb0, 0xa2, 0xb9, 0x88, 0x4d, 0x5c, 0x2a, 0x78, 0xac, 0x92, 
    0x2d, 0x67, 0xbf, 0x44, 0x96, 0xf0, 0x9d, 0x8e, 0x32, 0x9e, 0x54, 0x1c, 
    0x98, 0x15, 0x9d, 0x2a, 0xed, 0x2b, 0xa5, 0x17, 0x8c, 0x4a, 0x6c, 0xac, 
    0x02, 0x1d, 0x59, 0x99, 0xef, 0x19, 0x08, 0xa1, 0xbf, 0x19, 0xb6, 0xe8, 
    0x21, 0xb5, 0x94, 0x3d, 0x1d, 0xe1, 0xce, 0x08, 0x15, 0x8c, 0x1e, 0x9d, 
    0x4f, 0xd5, 0x88, 0x72, 0x2f, 0x45, 0xe5, 0xf8, 0x66, 0x7f, 0xa5, 0x7a, 
    0x94, 0xfd, 0xe8, 0xbb, 0x24, 0x3a, 0x52, 0x32, 0xcc, 0x24, 0x65, 0xad, 
    0x61, 0x40, 0x98, 0xf1, 0x70, 0xb5, 0xf5, 0xa8, 0x18, 0x69, 0x5b, 0x4f, 
    0x33, 0x85, 0x36, 0xf9, 0x76, 0x47, 0xa0, 0xcd, 0x53, 0x85, 0xd7, 0x34, 
    0xc3, 0x59, 0x3f, 0x5a, 0xe9, 0xbd, 0xe0, 0x6d, 0x69, 0x92, 0x50, 0x10, 
    0xc5, 0xaf, 0x7c, 0x81, 0x32, 0xa5, 0x4e, 0x0b, 0x08, 0xf7, 0xec, 0xd5, 
    0x08, 0xc8, 0x3b, 0xe3, 0x09, 0x52, 0x67, 0xaf, 0xed, 0x60, 0xce, 0x7b, 
    0xc0, 0xd5, 0x9d, 0xb4, 0x7b, 0x8b, 0x72, 0x1a, 0x8c, 0x71, 0xb1, 0x23, 
    0x55, 0xa6, 0x88, 0x07, 0x40, 0xbd, 0x63, 0x45, 0xe7, 0xfa, 0x6e, 0x7d, 
    0xe0, 0xf2, 0xb5, 0x69, 0x2b, 0xea, 0xda, 0xa7, 0xbb, 0x35, 0x2e, 0xea, 
    0x67, 0x39, 0x47, 0xa0, 0x79, 0x51, 0xa6, 0x2b, 0xe0, 0x83, 0x9b, 0xd3, 
    0xff, 0x8c, 0x05, 0x53, 0x2a, 0xac, 0x43, 0x8f, 0xf4, 0x53, 0xe8, 0x75, 
    0x7c, 0xee, 0x11, 0x9a, 0x54, 0xe4, 0x0a, 0x5c, 0x7f, 0x7d, 0x71, 0xbf, 
    0x9d, 0x49, 0x25, 0xd8, 0xba, 0xf7, 0xf6, 0x14, 0xca, 0xd4, 0xbd, 0xb1, 
    0xae, 0x6b, 0x4a, 0x87, 0xba, 0xd3, 0x2a, 0xd3, 0x37, 0x7e, 0x28, 0x4c, 
    0xa9, 0x0d, 0x50, 0xe9, 0x3a, 0x7c, 0xa9, 0xf4, 0x89, 0xc0, 0xb2, 0xce, 
    0xe0, 0x71, 0x98, 0xfe, 0x69, 0x8c, 0x34, 0xdd, 0xa3, 0x5a, 0xaf, 0xac, 
    0x48, 0x7e, 0xee, 0xde, 0x55, 0x73, 0x81, 0xe8, 0x34, 0x6e, 0xe7, 0x84, 
    0x24, 0x64, 0xd6, 0x97, 0xa9, 0xe0, 0xf6, 0x19, 0x08, 0x16, 0x4e, 0xb0, 
    0x03, 0x45, 0x76, 0x53, 0x60, 0x99, 0xb3, 0xd9, 0xb6, 0x1a, 0xa9, 0x61, 
    0x47, 0x0b, 0x89, 0x31, 0x82, 0x61, 0xb7, 0xd5, 0x94, 0x1a, 0xfd, 0x53, 
    0x4a, 0xfc, 0xc5, 0x62, 0xd9, 0xb8, 0x43, 0xde, 0x57, 0x7a, 0x93, 0x68, 
    0x7c, 0x3c, 0x68, 0xc2, 0x5f, 0xcb, 0x54, 0x57, 0x89, 0xee, 0xb7, 0x8a, 
    0x68, 0x97, 0x02, 0x7a, 0xaa, 0xb6, 0x6b, 0xc9, 0xd4, 0xac, 0x49, 0x99, 
    0xbd, 0x6f, 0xca, 0x2c, 0x89, 0x99, 0xb1, 0x7a, 0x27, 0x43, 0x42, 0x5c, 
    0x15, 0x67, 0x97, 0xb3, 0xfe, 0x08, 0x73, 0x69, 0xcd, 0x14, 0xf7, 0xcf, 
    0x0e, 0x98, 0x96, 0x12, 0x96, 0x2a, 0xcd, 0x76, 0xe9, 0x87, 0xc5, 0x2a, 
    0x43, 0xa9, 0xbd, 0x2d, 0xdb, 0x59, 0x21, 0x97, 0xe4, 0xce, 0x67, 0xc4, 
    0x2f, 0x20, 0x53, 0xb1, 0xe7, 0xb6, 0xb3, 0xb4, 0x62, 0x58, 0x03, 0x19, 
    0x23, 0x4d, 0xf1, 0x6a, 0x66, 0x84, 0xe0, 0x2e, 0x83, 0x1b, 0x42, 0x36, 
    0x68, 0x94, 0x33, 0xc7, 0x86, 0x49, 0x08, 0xa0, 0x71, 0x46, 0xbd, 0x9d, 
    0x53, 0x24, 0xf2, 0xe6, 0x4d, 0x32, 0xed, 0x6e, 0x27, 0x49, 0x73, 0x23, 
    0x02, 0xea, 0x97, 0x72, 0xde, 0xbf, 0xec, 0x5f, 0x24, 0x7d, 0xd4, 0x9a, 
    0x54, 0xa5, 0x03, 0xe1, 0x2a, 0xef, 0x6b, 0xeb, 0xd8, 0x4a, 0xb8, 0xd2, 
    0x46, 0x11, 0x1a, 0x7c, 0xdf, 0x0c, 0xcf, 0x8c, 0x96, 0x16, 0x4b, 0xda, 
    0x68, 0xbf, 0xa5, 0x55, 0x60, 0xf7, 0xf4, 0x7f, 0x03, 0x17, 0x5f, 0x7a, 
    0x90, 0x04, 0x5f, 0xf6, 0xae, 0x08, 0x48, 0x52, 0x7d, 0x75, 0x0a, 0x3d, 
    0x52, 0xd4, 0x48, 0x71, 0x5f, 0xd7, 0x77, 0x54, 0x07, 0x66, 0x24, 0xbd, 
    0x21, 0x13, 0xdc, 0x5d, 0xc6, 0xa5, 0xd4, 0xdb, 0x0e, 0x60, 0x59, 0xe3, 
    0x9a, 0xa4, 0x78, 0x27, 0xe2, 0xb3, 0xb7, 0x91, 0xeb, 0x3e, 0x26, 0x83, 
    0xc3, 0x1e, 0xfb, 0xde, 0xa5, 0xae, 0x7c, 0x78, 0x99, 0xa4, 0xa4, 0x50, 
    0x61, 0x74, 0x66, 0x71, 0x21, 0x43, 0x92, 0x3a, 0x92, 0x34, 0xfb, 0xd0, 
    0xb6, 0xd0, 0x86, 0xf7, 0x56, 0x2b, 0x15, 0xc0, 0x93, 0x58, 0x16, 0x66, 
    0x2c, 0x60, 0x0f, 0x71, 0xb8, 0xba, 0xc4, 0x3b, 0x63, 0xbc, 0x77, 0xef, 
    0x0a, 0xbd, 0xde, 0x0e, 0x98, 0x58, 0xc4, 0xa9, 0xea, 0x1f, 0xf8, 0x0f, 
    0x3e, 0x32, 0x70, 0x7e, 0x50, 0x59, 0xc3, 0x36, 0x25, 0x96, 0xf4, 0xa1, 
    0x72, 0x5b, 0x29, 0xe7, 0x6c, 0xa0, 0xaa, 0xf7, 0x72, 0x89, 0xe9, 0x42, 
    0xfa, 0x52, 0x92, 0x66, 0xc0, 0xc7, 0x4b, 0x75, 0xc7, 0x22, 0x36, 0x6d, 
    0xeb, 0xc5, 0x24, 0x9d, 0xd9, 0x76, 0x0a, 0x91, 0xbd, 0xad, 0xd8, 0xb5, 
    0x3a, 0x6f, 0xd6, 0xc8, 0x9d, 0xf1, 0x5f, 0xe6, 0xc7, 0xae, 0xdc, 0x4d, 
    0x60, 0x6e, 0x18, 0x2d, 0x21, 0x66, 0xd2, 0xac, 0xc1, 0xde, 0x17, 0x49, 
    0xcb, 0xac, 0xc5, 0x93, 0x9a, 0x29, 0x33, 0xea, 0x60, 0x3c, 0x04, 0xf6, 
    0x99, 0xcd, 0xa6, 0xb3, 0xbc, 0x2a, 0xca, 0x3e, 0x48, 0xa4, 0xc2, 0x6d, 
    0xff, 0x93, 0xf9, 0x86, 0x59, 0x00, 0xdd, 0xef, 0x36, 0x70, 0x0e, 0xe3, 
    0x7c, 0xb0, 0x58, 0x46, 0x54, 0x08, 0xa5, 0xb4, 0xdb, 0x0f, 0xdb, 0x05, 
    0x74, 0x03, 0x5a, 0x82, 0xf0, 0x19, 0xd9, 0x99, 0x49, 0xf2, 0xc3, 0xc6, 
    0x16, 0x6d, 0x15, 0x61, 0x5d, 0xcc, 0xe3, 0x75, 0xf2, 0xe5, 0x77, 0x54, 
    0x44, 0x87, 0x3f, 0x85, 0xb8, 0xfb, 0xf1, 0xd2, 0xce, 0x25, 0x92, 0x1b, 
    0xc5, 0x6d, 0xef, 0xcb, 0xbe, 0x16, 0xa2, 0xad, 0xf1, 0x0f, 0x07, 0x2d, 
    0xdc, 0xed, 0xaa, 0x00, 0x38, 0x51, 0x11, 0x69, 0xee, 0x84, 0x2f, 0xf8, 
    0x5f, 0xc1, 0xf2, 0xba, 0xc6, 0x1d, 0xbb, 0x21, 0x01, 0x22, 0x70, 0x86, 
    0x84, 0xe2, 0xaf, 0xa1, 0xe1, 0x48, 0x35, 0x7e, 0xf2, 0xdd, 0x16, 0x15, 
    0xb9, 0x91, 0xb0, 0xad, 0x46, 0xa2, 0x2f, 0xe0, 0xaa, 0xcc, 0x5d, 0x9b, 
    0xcc, 0x2e, 0x04, 0x39, 0x00, 0x27, 0x6a, 0x45, 0x25, 0xea, 0x77, 0x89, 
    0x53, 0xe8, 0x2c, 0xa7, 0x1a, 0xd0, 0x05, 0xda, 0x8f, 0x64, 0x6c, 0x43, 
    0x72, 0x08, 0x10, 0x95, 0x7f, 0xfc, 0xf1, 0x97, 0x08, 0xda, 0xd3, 0xf7, 
    0xc5, 0xb1, 0x7c, 0x3d, 0xdb, 0x5a, 0x86, 0xf8, 0xf1, 0xfd, 0x73, 0x58, 
    0x5a, 0x02, 0xe5, 0x29, 0x95, 0x55, 0xf4, 0x1c, 0x92, 0xb8, 0x8d, 0x95, 
    0x5f, 0x86, 0x8d, 0x70, 0x1c, 0xb1, 0x42, 0x2c, 0x33, 0xf5, 0xd4, 0xf8, 
    0x51, 0x14, 0x67, 0x40, 0xd4, 0xdd, 0xf0, 0x04, 0x62, 0xe4, 0xf1, 0xfb, 
    0x17, 0x0f, 0xaa, 0xb7, 0x7c, 0x3b, 0x5a, 0x7c, 0x95, 0x18, 0x5b, 0x7b, 
    0xde, 0x38, 0xc7, 0x9d, 0x7f, 0x3b, 0xfa, 0x02, 0x77, 0x5b, 0x52, 0x16, 
    0x26, 0x54, 0x0d, 0x0f, 0x80, 0x66, 0xf3, 0x00, 0x2b, 0x93, 0xec, 0xe3, 
    0xa1, 0xda, 0x90, 0x7d, 0x92, 0x12, 0x88, 0x35, 0xa8, 0xbd, 0xc0, 0xe7, 
    0x74, 0x35, 0xde, 0x0d, 0x82, 0x89, 0x7a, 0x4e, 0x7f, 0x69, 0x19, 0xab, 
    0x0a, 0x41, 0x1e, 0x98, 0xc6, 0xfd, 0x5f, 0x0d, 0xc2, 0x1a, 0xab, 0xd6, 
    0xc7, 0x62, 0x88, 0x25, 0x5a, 0x7a, 0x2c, 0x09, 0x5f, 0xbb, 0xa2, 0x44, 
    0xcb, 0x5e, 0x1f, 0x11, 0x7b, 0x58, 0xf6, 0xd4, 0xf4, 0x3d, 0x7a, 0xb1, 
    0x11, 0x3d, 0xe3, 0x53, 0x7b, 0x52, 0x61, 0xfd, 0x4b, 0x87, 0x55, 0x03, 
    0xc9, 0x24, 0x25, 0xf4, 0x06, 0x5b, 0xe6, 0x2b, 0x26, 0x56, 0x08, 0x44, 
    0xc3, 0x71, 0x09, 0xdd, 0xb1, 0x49, 0x90, 0xd8, 0xd6, 0x3c, 0x8e, 0x40, 
    0xa7, 0xb4, 0x5e, 0xbd, 0xc7, 0xf5, 0x50, 0xd1, 0xb6, 0x0d, 0xef, 0x1c, 
    0xe4, 0x35, 0xd3, 0x1d, 0xbe, 0xc4, 0x00, 0xd5, 0xf3, 0x46, 0xc5, 0x3e, 
    0x8e, 0x56, 0x53, 0xe0, 0xfc, 0x05, 0x45, 0xdc, 0xcb, 0x63, 0x4f, 0x12, 
    0x05, 0xff, 0xf8, 0xb9, 0x7b, 0xee, 0x8a, 0xf8, 0x92, 0x99, 0x3b, 0xf1, 
    0x38, 0x0a, 0x17, 0x66, 0x01, 0x19, 0x35, 0x36, 0x64, 0x8f, 0xe7, 0x3c, 
    0x0b, 0x83, 0xf8, 0xef, 0x9f, 0xcb, 0x32, 0xa1, 0xe3, 0x0e, 0xfe, 0xae, 
    0x7b, 0xd7, 0x6f, 0x19, 0xf5, 0xd3, 0xa5, 0x25, 0x4a, 0xd5, 0x7a, 0xa6, 
    0x9b, 0xa7, 0x27, 0x3f, 0x77, 0xde, 0x29, 0x8a, 0xc5, 0x98, 0xba, 0x7e, 
    0xd9, 0xe4, 0xea, 0x82, 0x4a, 0x1c, 0x63, 0x43, 0x35, 0xd5, 0x3e, 0x03, 
    0xf9, 0xc3, 0x1a, 0x45, 0xd2, 0x16, 0x1d, 0x47, 0xf4, 0x57, 0x6e, 0x59, 
    0x43, 0xff, 0x7e, 0x36, 0xfd, 0xde, 0x1b, 0xf5, 0xfc, 0xa3, 0xbe, 0xc9, 
    0x5b, 0x2c, 0x2e, 0xf5, 0x21, 0xb3, 0xb6, 0x29, 
};
const size_t HARDCODED_SERVER_PUB_KEY_LEN = 1952;

uint8_t *shared_secret_bin = NULL;
size_t shared_secret_len = 0;

struct sockaddr_in serv_addr;

int skfd, r, w;
unsigned short serv_port;
char serv_ip[20];// = "127.0.0.1"; //152.67.7.144: cloudboot
WINDOW *input_win;		//ncurses window thingy
pthread_mutex_t screen_mutex;		//ncurses Window thread
pthread_t send_thread, recv_thread;	//chat thread
volatile sig_atomic_t chat_is_active = 1;

char rbuff[128];	//stores strings received frm server
char sbuff[128];	//stores wtv client inputs

void *send_handler(void *arg);
void *receive_handler(void *arg);
char *digitsToLetters( long number);
void generate_nonce(char *nonce_hex_buffer);
void calculate_sha256(const char *input,size_t input_len, char *output_hex_hash);
ssize_t recv_all(int sockfd, void *buf, size_t len);
long dhexchange();
void measure_latency(int sockfd);
int authenticateServer(int skfd, const char* password);
const char* addEmojis(const char* input);
long modexp(long base, long exp, long mod) {
    long result=1;
    base%=mod;
    while (exp>0) {
        if (exp&1) result=(result*base)%mod;
        exp>>=1;
        base=(base*base)%mod;
    }
    return result;
}

uint8_t* authenticated_kyber_exchange_client(int skfd) {
    OQS_STATUS status;
    OQS_KEM *kem = OQS_KEM_new(OQS_KEM_alg_kyber_768);
    OQS_SIG *sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);
    if (!kem || !sig) {
        fprintf(stderr, "ERROR: Failed to init OQS KEM/SIG\n");
        return NULL;
    }

    uint8_t *kyber_pk = malloc(kem->length_public_key);
    uint8_t *signature = malloc(sig->length_signature);
    uint8_t *ciphertext = malloc(kem->length_ciphertext);
    uint8_t *shared_secret_bin = malloc(kem->length_shared_secret);

    if (!kyber_pk || !signature || !ciphertext || !shared_secret_bin) {
        fprintf(stderr, "ERROR: Memory allocation failed in client exchange\n");
        goto cleanup;
    }

    // 1. Receive Kyber Public Key
    if (recv_all(skfd, kyber_pk, kem->length_public_key) < 0) {
        perror("CLIENT: Failed to receive Kyber public key\n");
        goto cleanup;
    }

    // 2. Receive Dilithium Signature
    if (recv_all(skfd, signature, sig->length_signature) < 0) {
        perror("CLIENT: Failed to receive signature\n");
        goto cleanup;
    }

    // 3. --- VERIFY SIGNATURE ---	//TODO: LEARN how this prevents MiTM and in which stage
    status = OQS_SIG_verify(sig, kyber_pk, kem->length_public_key,
                            signature, sig->length_signature, HARDCODED_SERVER_PUB_KEY);
    if (status != OQS_SUCCESS) {
        fprintf(stderr, "\n\n\033[0;31m*** CRITICAL SECURITY FAILURE ***\033[0m\n");
        fprintf(stderr, "\033[0;31m!!! SERVER SIGNATURE VERIFICATION FAILED. POSSIBLE MAN-IN-THE-MIDDLE ATTACK !!!\033[0m\n");
        fprintf(stderr, "\033[0;31m!!! ABORTING CONNECTION !!!\033[0m\n\n");
        goto cleanup; // ABORT
    }
    printf("CLIENT: Server identity verified successfully via Dilithium signature\n");

    // 4. Verification passed. Proceed with Kyber KEM.
    status = OQS_KEM_encaps(kem, ciphertext, shared_secret_bin, kyber_pk);
    if (status != OQS_SUCCESS) { fprintf(stderr, "ERROR: OQS_KEM_encaps failed\n"); goto cleanup; }

    // 5. Send Kyber Ciphertext
    if (write(skfd, ciphertext, kem->length_ciphertext) < 0) { perror("write ciphertext"); goto cleanup; }

    // Success path: Clean up everything except the shared secret
    free(kyber_pk);
    free(signature);
    free(ciphertext);
    OQS_KEM_free(kem);
    OQS_SIG_free(sig);
    return shared_secret_bin;

cleanup:
    // Error path: Clean up everything
    free(kyber_pk);
    free(signature);
    free(ciphertext);
    free(shared_secret_bin);
    OQS_KEM_free(kem);
    OQS_SIG_free(sig);
    return NULL;
}

// Returns the length of the ciphertext. -1 on failure.
int aes_gcm_encrypt(const unsigned char *plaintext, int plaintext_len,
                    const unsigned char *key,
                    unsigned char *iv,        // OUT: 12-byte IV
                    unsigned char *ciphertext, // OUT: ciphertext
                    unsigned char *tag) {      // OUT: 16-byte GCM tag

    EVP_CIPHER_CTX *ctx;
    int len;
    int ciphertext_len;

    // Create and initialise the context
    if(!(ctx = EVP_CIPHER_CTX_new())) return -1;

    // Generate a random IV for each message (CRITICAL for security)
    if(1 != RAND_bytes(iv, 12)) return -1;

    // Initialise the encryption operation.
    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv)) return -1;

    // Provide the message to be encrypted, and obtain the encrypted output.
    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) return -1;
    ciphertext_len = len;

    // Finalise the encryption.
    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) return -1;
    ciphertext_len += len;

    // Get the GCM tag
    if(1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag)) return -1;

    // Clean up
    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}
// Returns the length of the plaintext. -1 on failure (e.g., tag mismatch).
int aes_gcm_decrypt(const unsigned char *ciphertext, int ciphertext_len,
                    const unsigned char *tag,
                    const unsigned char *key,
                    const unsigned char *iv,
                    unsigned char *plaintext) { // OUT: plaintext

    EVP_CIPHER_CTX *ctx;
    int len;
    int plaintext_len;
    int ret;

    // Create and initialise the context
    if(!(ctx = EVP_CIPHER_CTX_new())) return -1;

    // Initialise the decryption operation.
    if(!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv)) return -1;

    // Provide the message to be decrypted, and obtain the plaintext output.
    if(!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) return -1;
    plaintext_len = len;

    // Set the expected GCM tag. This is the integrity check.
    if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, (void*)tag)) return -1;

    // Finalise the decryption. A positive return value indicates success,
    // anything else is a failure - the plaintext is not trustworthy.
    ret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);

    // Clean up
    EVP_CIPHER_CTX_free(ctx);

    if(ret > 0) {
        plaintext_len += len;
        return plaintext_len;
    } else {
        // Tag verification failed!
        return -1;
    }
}


int main(int argc, char *argv[]) {
	bzero(&serv_addr, sizeof(serv_addr));//TODO:change to memset

	printf("Enter Server IP:");
	scanf("%s",serv_ip);

	printf("Enter Server Port: ");
	scanf("%hu",&serv_port);

	serv_addr.sin_family=AF_INET;
	serv_addr.sin_port=htons(serv_port);
	inet_aton(serv_ip, (&serv_addr.sin_addr));

	printf("<ANON COMM: CLIENT CLI>\n");

	if((skfd=socket(AF_INET, SOCK_STREAM,0))<0)
	{
		printf("CLIENT ERROR cannot create socket");
		exit(1);
	}

	if((connect(skfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)))<0)
	{
		printf("%d\n",skfd);
		printf("Client Error: connect to server");
		close(skfd);
		exit(1);
	}
	printf("CLIENT connected to server\n");

	fd_set read_fds;
    struct timeval timeout;
    int select_ret;

    FD_ZERO(&read_fds);
    FD_SET(skfd, &read_fds);

    // Set a short timeout (e.g., 200 milliseconds)
    timeout.tv_sec = 0;
    timeout.tv_usec = 200000; // 200ms

    // Check if the socket is immediately readable
    select_ret = select(skfd + 1, &read_fds, NULL, NULL, &timeout);

    if (select_ret < 0) {
        perror("select() error");
        close(skfd);
        exit(1);
    } else if (select_ret > 0 && FD_ISSET(skfd, &read_fds)) {
        // Socket is readable. Server sent an immediate rejection message.
        char rejection_buffer[512];
        int n = read(skfd, rejection_buffer, sizeof(rejection_buffer) - 1);
        if (n > 0) {
            rejection_buffer[n] = '\0';
            fprintf(stderr, "\n\033[0;31mServer Response:\n%s\033[0m\n", rejection_buffer);
        } else {
            fprintf(stderr, "\n\033[0;31mConnection rejected by server (reason unknown).\033[0m\n");
        }
        close(skfd); // Close the connection
        exit(1);     // Exit the client
    }
    // else if (select_ret == 0): Timeout occurred. This is the GOOD case.
    // Server did not immediately reject us. We can proceed.
    printf("CLIENT: Rudimentary connection established\n");


    // ---===[ 2. Proceed with User Authentication (SCRAM-like) ]===---
	printf("\033[0;33mEnter password: \033[0m ");
    scanf("%s", sbuff); // Use sbuff to get the password

    if (!authenticateServer(skfd, sbuff)) {
        // authenticateServer will print the specific error (e.g., "FAIL" or "Server proof incorrect")
		printf("\033[0;31mAUTH FAILED! CLOSING CONNECTION...\033[0m\n");
		close(skfd);
		exit(1);
   	}

    // ---===[ 3. Proceed with Authenticated Key Exchange (Dilithium+Kyber) ]===---
    shared_secret_bin = authenticated_kyber_exchange_client(skfd);
	if (shared_secret_bin == NULL) {
		printf("Authenticated key exchange failed. Exiting.\n");
		close(skfd);
		return 1;
	}

	//const long key=dhexchange();
	printf("\aCLIENT: \033[0;32mAUTHENTICATION SUCCESSFUL!\033[0m\n");
	fflush(stdout);

	measure_latency(skfd);		//measure and display ping

	//char *charKey=digitsToLetters(shared_key_string);
	printf("Client key: %s\n", shared_secret_bin);	//key for the session
	fflush(stdout);
	r=read(skfd,rbuff,128);		//read message of day frm server
	rbuff[r]='\0';
	printf("Word of the day is:  %s",rbuff);
	chat_is_active=1;

	printf("\n:::Type \033[0;31m'STOP'\033[0m to end the connection:::\n");	//chat threads
	sleep(2);//2sec delay
	initscr();
	start_color();
    	cbreak();	//---BEGIN NCURSES MODE---

	int height, width;
    	getmaxyx(stdscr, height, width);
    	scrollok(stdscr, TRUE);	//enable scrolling thru chat
    	// Clear the main screen before we start
    	clear();
    	refresh();

    	// Create a 1-line-high window at the bottom of the screen for input
   	input_win = newwin(1, width, height - 1, 0);

    	pthread_mutex_init(&screen_mutex, NULL);

    	wprintw(stdscr, "--- Chat Session Started ---\n");
    	wrefresh(stdscr);

	// Initialize the mutex
	pthread_mutex_init(&screen_mutex, NULL);

	if (pthread_create(&send_thread, NULL, send_handler, NULL) != 0) {
		perror("SERVER: Failed to create send thread\n");
		free(shared_secret_bin);
        	close(skfd);
		exit(1);
	}
	if (pthread_create(&recv_thread, NULL, receive_handler, NULL) != 0) {
		perror("SERVER: Failed to create receive thread\n");
		pthread_cancel(send_thread);
		free(shared_secret_bin);
        	close(skfd);
		exit(1);
	}

	pthread_join(send_thread, NULL);
	pthread_join(recv_thread, NULL);
	getmaxyx(stdscr, height, width);
	char line_buffer[width + 1];	//store last few lines of chat history
	pthread_mutex_destroy(&screen_mutex);
	endwin();
	for (int i = 0; i < height - 1; i++) {
		mvwinnstr(stdscr, i, 0, line_buffer, width);
		char *end = line_buffer + strlen(line_buffer) - 1;
		 while (end >= line_buffer && isspace((unsigned char)*end)) end--;
		*(end + 1) = '\0';
		if (strlen(line_buffer) > 0)
		printf("%s\n", line_buffer);
	}
    	printf("---------------------------\n");
	close(skfd);
	free(shared_secret_bin);
	exit(1);
}

void *send_handler(void *arg) {
    char plaintext_buff[MSG_BUF_SIZE];
    char prompt[] = "> ";

    // Buffers for the AES-GCM components
    unsigned char iv[IV_LEN];
    unsigned char tag[TAG_LEN];
    unsigned char ciphertext_buff[MSG_BUF_SIZE];

    // A single buffer to assemble our network packet
    unsigned char packet_buff[MSG_BUF_SIZE + IV_LEN + TAG_LEN];

    while (chat_is_active) {
        wgetstr(input_win, plaintext_buff);
        if (!chat_is_active) break;
        const char* final_message = addEmojis(plaintext_buff);

        // Display your own message in plaintext locally
        pthread_mutex_lock(&screen_mutex);
        wprintw(stdscr, "%s%s\n", prompt, final_message);
        wnoutrefresh(stdscr);
        wclear(input_win);
        wnoutrefresh(input_win);
        doupdate();
        pthread_mutex_unlock(&screen_mutex);

        // Encrypt the message
        int ciphertext_len = aes_gcm_encrypt(
            (unsigned char*)final_message, strlen(final_message),
            shared_secret_bin,
            iv, ciphertext_buff, tag
        );
        if (ciphertext_len < 0) {
            // This is a critical error, encryption failed
            break;
        }

        // Assemble the packet: [IV][TAG][CIPHERTEXT]
        memcpy(packet_buff, iv, IV_LEN);
        memcpy(packet_buff + IV_LEN, tag, TAG_LEN);
        memcpy(packet_buff + IV_LEN + TAG_LEN, ciphertext_buff, ciphertext_len);

        size_t packet_len = IV_LEN + TAG_LEN + ciphertext_len;

        // Send the entire packet
        if (write(skfd, packet_buff, packet_len) < 0) {
            break;
        }

        if (strcmp(plaintext_buff, "STOP") == 0) {
            chat_is_active=0;
            break;
        }
    }

    chat_is_active = 0;
    shutdown(skfd, SHUT_RDWR);
    pthread_exit(NULL);
}

void *receive_handler(void *arg) {
    unsigned char packet_buff[MSG_BUF_SIZE + IV_LEN + TAG_LEN];
    unsigned char iv[IV_LEN];
    unsigned char tag[TAG_LEN];
    unsigned char ciphertext_buff[MSG_BUF_SIZE];
    unsigned char plaintext_buff[MSG_BUF_SIZE];
    int bytes_read;

    while (chat_is_active) {
        bytes_read = read(skfd, packet_buff, sizeof(packet_buff));
        if (bytes_read <= 0) {
            break;
        }

        // Ensure we have at least enough data for the IV and tag
        if (bytes_read < IV_LEN + TAG_LEN) {
            continue; // Invalid packet, ignore
        }

        // Disassemble the packet: [IV][TAG][CIPHERTEXT]
        memcpy(iv, packet_buff, IV_LEN);
        memcpy(tag, packet_buff + IV_LEN, TAG_LEN);
        int ciphertext_len = bytes_read - IV_LEN - TAG_LEN;
        memcpy(ciphertext_buff, packet_buff + IV_LEN + TAG_LEN, ciphertext_len);

        // Decrypt and verify the message
        int plaintext_len = aes_gcm_decrypt(
            ciphertext_buff, ciphertext_len,
            tag, shared_secret_bin, iv,
            plaintext_buff
        );

        //pthread_mutex_lock(&screen_mutex);//TEST

        if (plaintext_len < 0) {
            // DECRYPTION FAILED! Tag mismatch means the message was tampered with.
            wprintw(stdscr, "[!] SECURITY ALERT: Received a corrupted or tampered message.\n");
        } else {
            // Decryption successful, display the plaintext
            init_pair(1, COLOR_CYAN, COLOR_BLACK);
            attron(COLOR_PAIR(1));
            plaintext_buff[plaintext_len] = '\0';
            wprintw(stdscr, "Server says: %s\n", plaintext_buff);
            attroff(COLOR_PAIR(1));
        }

        wnoutrefresh(stdscr);
        wnoutrefresh(input_win);
        doupdate();
        //pthread_mutex_unlock(&screen_mutex)//TEST

        if (strcmp((char*)plaintext_buff, "STOP") == 0) {
            chat_is_active=0;
            break;
        }
    }

    chat_is_active = 0;
    shutdown(skfd, SHUT_RDWR);
    pthread_exit(NULL);
}

void generate_nonce(char *nonce_hex_buffer) {
    unsigned char nonce_bin[NONCE_LEN];
    if (1 != RAND_bytes(nonce_bin, NONCE_LEN)) {
        perror("RAND_bytes failed");
        exit(1);
    }

    for (int i = 0; i < NONCE_LEN; i++) {//conv to hex
        sprintf(nonce_hex_buffer + (i * 2), "%02x", nonce_bin[i]);
    }
    nonce_hex_buffer[NONCE_HEX_LEN - 1] = '\0';
}

void calculate_sha256(const char *input, size_t input_len, char *output_hex_hash) {
    EVP_MD_CTX *mdctx;
    const EVP_MD *md;
    unsigned char hash_bin[SHA256_DIGEST_LENGTH];
    unsigned int hash_len;

    // 1. Get the SHA256 message digest type
    md = EVP_sha256();
    if (md == NULL) {
        fprintf(stderr, "EVP_sha256() failed\n");
        exit(1);
    }
    // 2. Create and initialize the context
    mdctx = EVP_MD_CTX_new();
    if (mdctx == NULL) {
        fprintf(stderr, "EVP_MD_CTX_new() failed\n");
        exit(1);
    }
    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {
        fprintf(stderr, "EVP_DigestInit_ex() failed\n");
        EVP_MD_CTX_free(mdctx);
        exit(1);
    }
    // 3. Provide the data to be hashed
    if (1 != EVP_DigestUpdate(mdctx, input, input_len)) {
        fprintf(stderr, "EVP_DigestUpdate() failed\n");
        EVP_MD_CTX_free(mdctx);
        exit(1);
    }
    // 4. Finalize the hash
    if (1 != EVP_DigestFinal_ex(mdctx, hash_bin, &hash_len)) {
        fprintf(stderr, "EVP_DigestFinal_ex() failed\n");
        EVP_MD_CTX_free(mdctx);
        exit(1);
    }
    // 5. Clean up the context
    EVP_MD_CTX_free(mdctx);

    // Sanity check: Ensure the output length is correct for SHA256
    if (hash_len != SHA256_DIGEST_LENGTH) {
        fprintf(stderr, "SHA256 output length mismatch!\n");
        exit(1);
    }
    // 6. Convert the binary hash to a hex string
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_hex_hash + (i * 2), "%02x", hash_bin[i]);
    }
    // HASH_LEN should be 65 (SHA256_DIGEST_LENGTH * 2 + 1)
    output_hex_hash[SHA256_HEX_LEN * 2] = '\0';
}

ssize_t recv_all(int sockfd, void *buf, size_t len) {
    size_t total_read = 0;
    while (total_read < len) {
        ssize_t bytes_read = read(sockfd, (char*)buf + total_read, len - total_read);
        if (bytes_read <= 0) {
            // Error or connection closed
            return -1;
        }
        total_read += bytes_read;
    }
    return total_read;
}

long dhexchange() {
	srand(time(NULL) ^ getpid());
	const long y2=rand() % 900000 + 100000;
	long base,mod,r1;
	recv(skfd, &base, sizeof(base), 0);
	recv(skfd, &mod, sizeof(mod), 0);
	if (recv(skfd, &r1, sizeof(r1), 0) != sizeof(r1)) {
	    //perror("recv r1");
	    close(skfd);
	    return 0;
	}
	long r2=modexp(base,y2,mod);
	send(skfd, &r2, sizeof(r2), 0);

	return modexp(r1, y2, mod);
}

char *digitsToLetters( long number) {
    char numstr[128];	//time wont be more than 10
    snprintf(numstr, sizeof(numstr), "%ld", number);

    size_t len = strlen(numstr);
    char *result = malloc(len + 1); // +1 for null terminator
    if (!result) return NULL;
    for (size_t i=0;i<len;i++) {
        if (isdigit((unsigned char)numstr[i])) {
            int digit = numstr[i] - '0';        // 0–9
            result[i] = 'A' + digit;            // A–J
        }
    }
    result[len]='\0';
    return result;
}

void measure_latency(int sockfd) {
    const char *ping_msg="LATENCY_PING";
    char buffer[32];
    struct timespec start, end;

    clock_gettime(CLOCK_MONOTONIC, &start);
    write(sockfd, ping_msg, strlen(ping_msg));
    read(sockfd, buffer, sizeof(buffer) - 1);
    clock_gettime(CLOCK_MONOTONIC, &end);

    double rtt_ms = (end.tv_sec - start.tv_sec) * 1000.0 + (end.tv_nsec - start.tv_nsec) / 1000000.0;
    printf("Connection Latency (RTT):\033[0;32m %.2f ms\033[0m\n", rtt_ms);
}

int authenticateServer(int skfd, const char* password) {
    char client_nonce[NONCE_HEX_LEN];
    char server_nonce[NONCE_HEX_LEN];
    char server_proof_from_server[SHA256_HEX_LEN];
    char local_client_proof[SHA256_HEX_LEN];
    char local_server_proof[SHA256_HEX_LEN];
    char proof_input_buffer[512];
    int bytes_read;

    // 1. Generate and send the client's challenge (client_nonce)
    generate_nonce(client_nonce);
    if (write(skfd, client_nonce, strlen(client_nonce)) <= 0) {
        printf("Failed to write client nonce.\n");
        return 0;
    }

    // 2. Wait for the server's challenge (server_nonce)
    bytes_read = recv_all(skfd, server_nonce, NONCE_HEX_LEN - 1);
    if (bytes_read <= 0) {
        printf("CLIENT: Failed to read server nonce.\n");
        return 0;
    }
    server_nonce[bytes_read] = '\0';

    // 3. Generate and send the client's proof
    int len_to_hash=sprintf(proof_input_buffer, "%s%s%s", password, client_nonce, server_nonce);
    calculate_sha256(proof_input_buffer, len_to_hash, local_client_proof);

    if (write(skfd, local_client_proof, strlen(local_client_proof)) <= 0) {
        printf("CLIENT: Failed to write client proof.\n");
        return 0;
    }

    // 4. Wait for and verify the server's proof
    bytes_read = recv_all(skfd, server_proof_from_server, SHA256_HEX_LEN - 1);
    if (bytes_read <= 0) {
        printf("CLIENT: Failed to read server proof. Recheck password\n");
        return 0;
    }
    server_proof_from_server[bytes_read] = '\0';

    // Check if the server rejected our proof
    if (strcmp(server_proof_from_server, "FAIL") == 0) {
        printf("Authentication FAILED! Server rejected our proof.\n");
        return 0;
    }

    // 5. Verify the server's proof
    len_to_hash=sprintf(proof_input_buffer, "%s%s%s", password, server_nonce, client_nonce);
    calculate_sha256(proof_input_buffer, len_to_hash, local_server_proof);

    if (strcmp(local_server_proof, server_proof_from_server) != 0) {
        printf("\a\033[0;31mCRITICAL: Server authentication FAILED. Possible Replay attack!\033[0m\n");
        return 0;
    }

    return 1;
}

const char* addEmojis(const char* input) {
    if (strcmp(input, "/shrug") == 0) {
        return "¯\\_(ツ)_/¯";
    }
    if (strcmp(input, "/happy") == 0) {
        return "(・3・)";
    }
    if (strcmp(input, "/lol") == 0 || strcmp(input, "/laugh") == 0 || strcmp(input, "/lmao") == 0) {
        return "L(° O °L)";
    }
    if (strcmp(input, "/tableflip") == 0) {
        return "(╯°□°）╯︵ ┻━┻";
    }
    if (strcmp(input, "/sad") == 0) {
        return "(´סּ︵סּ`)";
    }
    if (strcmp(input, "/unflip") == 0) {
        return "┬─┬ ノ( ゜-゜ノ)";
    }
    return input;
}
